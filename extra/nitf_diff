#! /usr/bin/env python
from __future__ import print_function
import pynitf
import importlib.util
import sys
import logging
import json
import os
import collections.abc

version="January 17, 2020"

usage="""Usage: 
  nitf_diff [options] <file1> <file2>
  nitf_diff -h | --help
  nitf_diff -v | --version

This compares two nitf files, and determines if they are the same are not.

In general, there can be all kinds of special cases you want in a compare.
For example, you might want a particular image segment compared with a 
tolerance rather than exactly. You might want a TRE compared, but ignore
certain fields for example, or use a special way to compare images. We
take configuration information to control this.

There are two forms of configuration data. For simpler configuration, 
a JSON file can be supplied. This provides a configuration hash that is
merged in with the default configuration set up in pynitf and other 
modules listed on NITF_PLUGIN environment variable list.

If you need to supply special handlers, you can load arbitrary python code.
The code should have the general format:

   import __main__
   __main__.nitf_info.handle_set.add_handle(my_handle)
   __main__.nitf_info.config["My key"] = "My value"

Options:
  -h --help         
       Print this message

  --config-file-json=f
       Give a json file to supply configuration parameters. This is merged
       in with the default configuration set up by pynitf.

   --config-file-python=f
       Load arbitrary python code from the given file.

  --debug
       Turn debugging information on
       
  --log-file=f
       Give a path for the logs to be written to

  --quiet
       Don't print any messages, just return an overall status code.

  --verbose
       Give more verbose messages (turn debugging on

  -v --version      
       Print program version

"""
args = pynitf.docopt_simple.docopt_simple(usage, version=version)

# Load plugins for nitf
if "NITF_PLUGIN" in os.environ:
    for m in os.environ["NITF_PLUGIN"].split(":"):
        exec("import %s" % m)

nitf_diff = pynitf.NitfDiff()

# TODO Remove this

# Temporarily skip things we haven't yet implemented. This will go away once
# we have all the parts of the nitf file checked.
nitf_diff.handle_set.add_handle(pynitf.AlwaysTrueHandle(), priority_order = -1)

if(args.config_file_json):
    with open(args.config_file_json) as json_file:
        nitf_diff.update_config(json.load(json_file))
if(args.config_file_python):
    spec = importlib.util.spec_from_file_location("config_file",
                                                  args.config_file_python)
    module = importlib.util.module_from_spec(spec)
    nspec.loader.exec_module(module)
    sys.modules["config_file"] = module

if(args.debug):
    logging.basicConfig(level=logging.DEBUG)
elif(args.verbose):
    logging.basicConfig(level=pynitf.NitfDiffHandle.INFO)
elif(args.quiet):
    logging.basicConfig(level=1000)
else:    
    logging.basicConfig(level=logging.WARNING)

is_same = nitf_diff.compare(args.file1, args.file2)

if(not is_same):
    logging.getLogger("nitf_diff").error("Files differ")
    sys.exit(1)
logging.getLogger("nitf_diff").info("Files are the same")
    
